# C問題
アルゴリズムは適切なものを考えることができたが，細かいところの微調整とTLEによってテストケースを通過できなかった．
この問題では，「ランレングス圧縮」によってメモリ効率よくデータを保存していくことが重要である．
また，計算値は最大で$10^{18}$になりうるため，long long 型で変数を指定する必要がある．

自分のコードから修正するべき点は以下のように挙げられる．
- pair でデータを管理<br>
    ペアを作らずにそのまま配列に追加していたため，配列へのアクセス性と可読性が低下していた．
    また，配列から削除するときにerase()を使用したが，erase()はO(N)で遅いためなるべく使いたくない．これをペアにして管理していると一回のerase()で2つの情報が消せるが，ペアにして管理していないと2回erase()が必要になり，かなり時間が変わる．
- long long 型の指定

| 型名                    | ビット数（目安）           | 値の範囲（符号あり）                    | メモリ使用量 | 備考・用途例                          |
|-------------------------|----------------------------|------------------------------------------|---------------|----------------------------------------|
| `short`                 | 16ビット                   | −32,768 ～ +32,767                       | 2バイト       | 古いCPU向け。現代では非推奨           |
| `int`                   | 32ビット                   | −2,147,483,648 ～ +2,147,483,647         | 4バイト       | 一般的な整数計算に使う標準型         |
| `long`（Windows）       | 32ビット                   | 同上（`int`と同じ）                      | 4バイト       | 実質 `int` と同じ                     |
| `long`（Linux）         | 64ビット                   | 約 −9×10¹⁸ ～ +9×10¹⁸                    | 8バイト       | Linux環境でのみ `long` = `long long`  |
| `long long`             | 64ビット                   | 約 −9×10¹⁸ ～ +9×10¹⁸                    | 8バイト       | 大きな整数に対応（競プロでも定番）    |
| `unsigned int`          | 32ビット                   | 0 ～ 約 4,294,967,295                    | 4バイト       | 正のカウント値に便利                  |
| `unsigned long long`    | 64ビット                   | 0 ～ 約 18,446,744,073,709,551,615       | 8バイト       | 正の超巨大な数を扱う場合に使用        |

